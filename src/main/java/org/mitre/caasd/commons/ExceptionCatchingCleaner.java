/*
 *    Copyright 2022 The MITRE Corporation
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package org.mitre.caasd.commons;

import static com.google.common.base.Preconditions.checkNotNull;

import java.util.Optional;

import org.mitre.caasd.commons.Functions.ToStringFunction;
import org.mitre.caasd.commons.util.ExceptionHandler;
import org.mitre.caasd.commons.util.SequentialFileWriter;

/**
 * An ExceptionCatchingCleaner decorates an existing DataCleaner with Exception catching behavior.
 * <p>
 * Any Exceptions that arise while passing data to the wrapped DataCleaner will be caught and passed
 * to the ExceptionHandler provided at construction.
 */
public class ExceptionCatchingCleaner<T> implements DataCleaner<T> {

    private final DataCleaner<T> cleaner;

    private final ToStringFunction<T> messageMaker;

    private final ExceptionHandler errorHandler;

    /**
     * Create an ExceptionCatchingCleaner that will catch Exceptions caused while applying the
     * DataCleaner supplied here and pass those exceptions to an ExceptionHandler.
     *
     * @param cleaner      An existing DataCleaner.
     * @param toString     This function is applied to an input if that input caused an exception
     *                     when the DataCleaner was applied. Consequently, this function should make
     *                     useful error messages given what type of data is being cleaned.
     * @param errorHandler Catches any exceptions thrown during data cleaning.
     */
    public ExceptionCatchingCleaner(DataCleaner<T> cleaner, ToStringFunction<T> toString, ExceptionHandler errorHandler) {
        this.cleaner = checkNotNull(cleaner);
        this.messageMaker = checkNotNull(toString);
        this.errorHandler = checkNotNull(errorHandler);
    }

    /**
     * Create an ErrorCatchingCleaner that produces one error file for each piece of data that
     * causes and exception during data cleaning. Each error file contains (1) the "toString()-ed"
     * version of the data that generated the exception and (2) the stack trace of the exception
     * that was caught.
     *
     * @param cleaner An existing DataCleaner
     */
    public ExceptionCatchingCleaner(DataCleaner<T> cleaner) {
        this(
            cleaner,
            (T item) -> item.toString(),
            new SequentialFileWriter("caughtInDataCleaning")
        );
    }

    /**
     * Apply the wrapped DataCleaner and pipe any exceptions to the ErrorHandler provided at
     * construction.
     *
     * @param data A piece of data that needs to be cleaned.
     *
     * @return The output generated by the wrapped DataCleaner, or Optional.empty() if applying the
     *     wrapped DataCleaner
     */
    @Override
    public Optional<T> clean(T data) {
        try {
            return cleaner.clean(data);
        } catch (Exception ex) {
            String message = messageMaker.apply(data);
            errorHandler.handle(message, ex);
            return Optional.empty();
        }
    }
}
